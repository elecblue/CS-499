import{f as u,t as p,a as i}from"../chunks/DKazGl9Q.js";import"../chunks/9NV8XBfB.js";import{e as g,s as m,f,c as b,$ as y,n,r as v}from"../chunks/BcuyA5r3.js";import{h as w}from"../chunks/CP5aAG9p.js";import{C as k}from"../chunks/CmSR4sbs.js";import{b as s}from"../chunks/Bv19MXrd.js";import{B as x}from"../chunks/aHgMsoFa.js";var S=u(`<h2 id="overview">Final Narrative</h2> <p class="text-base/7">My final capstone submission (what I've dubbed <em>Rescue-Mate</em>) is a ground-up modernization of my original CS-340 artifact: the Python Dash + MongoDB Austin Animal Center dashboard (the one built around a single Dash app script plus a small CRUD helper module for database access). The original version was effective as a proof-of-concept. Dash made it fast to stand up a working UI, Plotly made charts painless, and MongoDB made the data model flexible, but it also concentrated a lot of responsibilities into a tight cluster of Python files (UI rendering, query logic, filtering rules, and database operations all living close together). That structure is totally normal for a course project, but it's harder to scale, test, and evolve like a real product. <br/><br/> In the final capstone version, I rebuilt the dashboard as a modern full-stack TypeScript web app using SvelteKit, a typed service/data layer, and a relational SQLite database managed through Drizzle ORM. The biggest design shift is intentional separation of concerns: database schema and queries are defined in a consistent, type-safe way; server-side endpoints/load functions handle filtering/pagination/sorting; and the UI focuses on presenting state and interactions (instead of also being the “data engine”). I also leaned into URL-driven state (query parameters) for things like filters and pagination so the app is shareable, refresh-safe, and predictable—if you copy a link, you get the same view and the same results. On the front end, components like the TanStack Table integration and the chart/map visualizations are built to be reusable and maintainable, rather than one-off chunks glued into a monolith. That chart component can also be easily changed to a different type of chart or even swapped with a different library if needed. <br/><br/> A few choices were very deliberate tradeoffs. Moving from MongoDB to SQLite + Drizzle gives me stronger structure and consistency (schema, constraints, and safer query composition), which matters when you want reliable filtering, sorting, and aggregation as the UI grows. While SQLite seems like an odd choice for something like this, it is merely a quick solution to sharing the dataset (the DB is included in the repo!)&mdash;changing to PostgreSQL or MySQL could be done by changing a line or two of code. Using TypeScript across the stack reduces surprises and makes refactoring safer—especially for a capstone where I'm iterating fast and documenting enhancements. And SvelteKit's server/client model lets me keep data access on the server (cleaner security boundaries and simpler deployment) while still delivering a snappy, app-like UI. Net result: the project evolved from a functional dashboard demo into something closer to production-grade software (modular, testable, and intentionally designed) while preserving the original goal: helping a user explore rescue-animal data through filtering, tables, and visualizations.</p> <h3 id="competencies">Course Outcomes</h3> <ul class="list-disc pl-6 leading-relaxed marker:text-primary/80"><li>Software design & architecture (SvelteKit, TypeScript, Drizzle ORM)</li> <li>Algorithms & data structures in service of UX</li> <li>Data modeling & visualization for decision support</li> <li>Security-by-default practices in app design</li></ul> <h3 id="downloads">Clone the Project</h3> <div class="flex flex-row items-center justify-center gap-4"><!></div> <h3 id="running">Running the Project</h3> <p class="text-base/7">To run the Rescue-Mate application locally, ensure you have <a href="https://bun.sh/" target="_blank">Bun</a> installed for the best experience (you should because it's great). Then, clone the repository and navigate to the app's directory. Install the dependencies using <code>bun install</code>, and start the development server with <code>bun run dev</code>. <br/><br/> The application will be accessible at <code>http://localhost:XXXX</code> depending on your configuration (or what Vite assigns you).</p>`,1);function R(o){const r={title:"Final Capstone Submission",hero:`${s}/images/frutiger-aero-01.png`,summary:"About the culmination of my capstone project: the Rescue-Mate animal rescue operations dashboard."},l={href:`${s}/about-me`,label:"Next: About Me →"};w("1gxxg8e",e=>{g(()=>{y.title="nik myers / capstone submission"})}),k(o,{get meta(){return r},get next(){return l},children:(e,$)=>{var t=S(),a=m(f(t),10),d=b(a);x(d,{href:"https://github.com/elecblue/CS-499/tree/main/app",type:"github",children:(c,D)=>{n();var h=p("View on GitHub");i(c,h)},$$slots:{default:!0}}),v(a),n(4),i(e,t)},$$slots:{default:!0}})}export{R as component};
